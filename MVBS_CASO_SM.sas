/**************************************************************************** 
 * Job:             MVBS_CASO_SM                          A5V8BXSQ.AR0001I6 * 
 * Description:                                                             * 
 *                                                                          * 
 * Metadata Server: bire-sas94-meta-dev.srv.allianz                         * 
 * Port:            8561                                                    * 
 * Location:        /ETL/tdbpcd/Jobs/MVBS/MVBS_OUTPUT                       * 
 *                                                                          * 
 * Server:          tdbpcd                                A5HYR2NS.AS00001O * 
 *                                                                          * 
 * Source Tables:   MVBS_EXCHANGE_RATE -                  A5V8BXSQ.AE0001VQ * 
 *                   RESASDWH.MVBS_EXCHANGE_RATE                            * 
 *                  MVBS_OUTPUT_4SM_AGG -                 A5V8BXSQ.AE0001WA * 
 *                   RESASDWH.MVBS_OUTPUT_4SM_AGG                           * 
 *                  META_MVBS_AMOUNT_TYPE -               A5V8BXSQ.AE0001TX * 
 *                   RESASDWH.META_MVBS_AMOUNT_TYPE                         * 
 *                  MVBS_OUTPUT_4SM_CDA -                 A5V8BXSQ.AE0001WC * 
 *                   RESASDWH.MVBS_OUTPUT_4SM_CDA                           * 
 *                  MVBS_OUTPUT_4SM_CASO -                A5V8BXSQ.AE0001WB * 
 *                   RESASDWH.MVBS_OUTPUT_4SM_CASO                          * 
 *                  MVBS_INTERIM_PC_INPUT -               A5V8BXSQ.AE0001VZ * 
 *                   RESASDWH.MVBS_INTERIM_PC_INPUT                         * 
 *                  META_MVBS_SUBJECT_FILTER -            A5V8BXSQ.AE0001UN * 
 *                   RESASDWH.META_MVBS_SUBJECT_FILTER                      * 
 *                  META_MVBS_SUBJECT_CONTROL -           A5V8BXSQ.AE0001UK * 
 *                   RESASDWH.META_MVBS_SUBJECT_CONTROL                     * 
 *                  MVBS_LOG - RESASDWH.MVBS_LOG          A5V8BXSQ.AE0001W3 * 
 *                                                                          * 
 * Generated on:    Monday, August 28, 2017 3:11:34 PM IST                  * 
 * Generated by:    re00580                                                 * 
 * Version:         SAS Data Integration Studio 4.902                       * 
 ****************************************************************************/ 

/* Generate the process id for job  */ 
%put Process ID: &SYSJOBID;

/* General macro variables  */ 
%let jobID = %quote(A5V8BXSQ.AR0001I6);
%let etls_jobName = %nrquote(MVBS_CASO_SM);
%let etls_userID = %nrquote(re00580);

/* Setup to capture return codes  */ 
%global job_rc trans_rc sqlrc;
%let sysrc = 0;
%let job_rc = 0;
%let trans_rc = 0;
%let sqlrc = 0;
%global etls_stepStartTime; 
/* initialize syserr to 0 */
data _null_; run;

%macro rcSet(error); 
   %if (&error gt &trans_rc) %then 
      %let trans_rc = &error;
   %if (&error gt &job_rc) %then 
      %let job_rc = &error;
%mend rcSet; 

%macro rcSetDS(error); 
   if &error gt input(symget('trans_rc'),12.) then 
      call symput('trans_rc',trim(left(put(&error,12.))));
   if &error gt input(symget('job_rc'),12.) then 
      call symput('job_rc',trim(left(put(&error,12.))));
%mend rcSetDS; 

/* Setup for capturing job status  */ 
%let etls_startTime = %sysfunc(datetime(),datetime.);
%let etls_recordsBefore = 0;
%let etls_recordsAfter = 0;
%let etls_lib = 0;
%let etls_table = 0;

%global etls_debug; 
%macro etls_setDebug; 
   %if %str(&etls_debug) ne 0 %then 
      OPTIONS MPRINT%str(;); 
%mend; 
%etls_setDebug; 

/*---- Start of Pre-Process Code  ----*/ 

/*Call to an initialization macro  */
%mvbsJobInit;
/*---- End of Pre-Process Code  ----*/ 

%rcSet(&syserr); 
%rcSet(&sqlrc); 

/*==========================================================================* 
 * Step:            MVBS TDB Get Version IDs              A5V8BXSQ.AW0003Y9 * 
 * Transform:       MVBS TDB Get Version IDs                                * 
 * Description:     1. input: MVBS_LOG2. input:                             * 
 *                  META_MVBS_SUBJECT_CONTROLReturns the IDs of             * 
 *                  signed-off data + the IDs of data that only requires    * 
 *                  an OK status. If there are no IDs avaible the job's     * 
 *                   rc is set to 1009.                                     * 
 *                                                                          * 
 * Source Tables:   META_MVBS_SUBJECT_CONTROL -           A5V8BXSQ.AE0001UK * 
 *                   RESASDWH.META_MVBS_SUBJECT_CONTROL                     * 
 *                  MVBS_LOG - RESASDWH.MVBS_LOG          A5V8BXSQ.AE0001W3 * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003Y9);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let _INPUT_count = 2; 
%let _INPUT = RESASDWH.META_MVBS_SUBJECT_CONTROL;
%let _INPUT_connect =  DBMAX_TEXT=32767 DBCLIENT_MAX_BYTES=1 ADJUST_BYTE_SEMANTIC_COLUMN_LENGTHS=YES ADJUST_NCHAR_COLUMN_LENGTHS=YES DB_LENGTH_SEMANTICS_BYTE=NO PATH="&ORA_RESASDWH_PATH" user="&ORA_RESASDWH_USER" pw="&ORA_RESASDWH_PWD"
;
%let _INPUT_engine = ORACLE;
%let _INPUT_memtype = DATA;
%let _INPUT_options = %nrquote();
%let _INPUT_alter = %nrquote();
%let _INPUT_path = %nrquote(/ETL/tdbpcd/Tables/Target/META/META_MVBS_SUBJECT_CONTROL%(Table%));
%let _INPUT_type = 1;
%let _INPUT_label = %nrquote();

%let _INPUT1 = RESASDWH.META_MVBS_SUBJECT_CONTROL;
%let _INPUT1_connect =  DBMAX_TEXT=32767 DBCLIENT_MAX_BYTES=1 ADJUST_BYTE_SEMANTIC_COLUMN_LENGTHS=YES ADJUST_NCHAR_COLUMN_LENGTHS=YES DB_LENGTH_SEMANTICS_BYTE=NO PATH="&ORA_RESASDWH_PATH" user="&ORA_RESASDWH_USER" pw="&ORA_RESASDWH_PWD"
;
%let _INPUT1_engine = ORACLE;
%let _INPUT1_memtype = DATA;
%let _INPUT1_options = %nrquote();
%let _INPUT1_alter = %nrquote();
%let _INPUT1_path = %nrquote(/ETL/tdbpcd/Tables/Target/META/META_MVBS_SUBJECT_CONTROL%(Table%));
%let _INPUT1_type = 1;
%let _INPUT1_label = %nrquote();

%let _INPUT2 = RESASDWH.MVBS_LOG;
%let _INPUT2_connect =  DBMAX_TEXT=32767 DBCLIENT_MAX_BYTES=1 ADJUST_BYTE_SEMANTIC_COLUMN_LENGTHS=YES ADJUST_NCHAR_COLUMN_LENGTHS=YES DB_LENGTH_SEMANTICS_BYTE=NO PATH="&ORA_RESASDWH_PATH" user="&ORA_RESASDWH_USER" pw="&ORA_RESASDWH_PWD"
;
%let _INPUT2_engine = ORACLE;
%let _INPUT2_memtype = DATA;
%let _INPUT2_options = %nrquote();
%let _INPUT2_alter = %nrquote();
%let _INPUT2_path = %nrquote(/ETL/tdbpcd/Tables/Target/MVBS/MVBS_LOG%(Table%));
%let _INPUT2_type = 1;
%let _INPUT2_label = %nrquote();

%let _OUTPUT_count = 0; 

%let macroVarName = %nrquote(list_of_versions);

%mvbsGetVersionIDs(mvbs_log=&_INPUT1., meta_mvbs_subject_control=&_INPUT2., returnValue=&macroVarName.);

%rcSet(&syserr); 
%rcSet(&sysrc); 
%rcSet(&sqlrc); 



/**  Step end MVBS TDB Get Version IDs **/

/*==========================================================================* 
 * Step:            Return Code Check                     A5V8BXSQ.AW0003YA * 
 * Transform:       Return Code Check                                       * 
 * Description:                                                             * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YA);
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%macro etls_rcCheck; 

   %if (&trans_rc ge 5) %then
   %do; 
      /* Abort with a return code of  &trans_rc  */ 
      %abort return  &trans_rc; 
   %end; 
   
%mend etls_rcCheck; 
%etls_rcCheck; 



/**  Step end Return Code Check **/

/*==========================================================================* 
 * Step:            Create Table                          A5V8BXSQ.AW0003YB * 
 * Transform:       Create Table                                            * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Table:    MVBS_EXCHANGE_RATE -                  A5V8BXSQ.AE0001VQ * 
 *                   RESASDWH.MVBS_EXCHANGE_RATE                            * 
 * Target Table:    Create Table - work.fx_rates          A5V8BXSQ.AQ0001NE * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YB);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let SYSLAST = %nrquote(RESASDWH.MVBS_EXCHANGE_RATE); 

%global etls_sql_pushDown;
%let etls_sql_pushDown = -1;
option DBIDIRECTEXEC;

proc datasets lib = work nolist nowarn memtype = (data view);
   delete fx_rates;
quit;

proc sql
;
create table work.fx_rates as
select
   MVBS_EXCHANGE_RATE.CURR1 length = 3   
      format = $3.
      informat = $3.
      label = 'CURR1',
   MVBS_EXCHANGE_RATE.CURR2 length = 3   
      format = $3.
      informat = $3.
      label = 'CURR2',
   MVBS_EXCHANGE_RATE.FROM_TIME length = 14   
      format = $14.
      informat = $14.
      label = 'FROM_TIME',
   MVBS_EXCHANGE_RATE.TO_TIME length = 14   
      format = $14.
      informat = $14.
      label = 'TO_TIME',
   MVBS_EXCHANGE_RATE.RATE length = 8   
      format = 21.8
      informat = 21.8
      label = 'RATE',
   MVBS_EXCHANGE_RATE.CATEGORY_TITLE length = 50   
      format = $50.
      informat = $50.
      label = 'CATEGORY_TITLE',
   MVBS_EXCHANGE_RATE.CATEGORY length = 15   
      format = $15.
      informat = $15.
      label = 'CATEGORY',
   MVBS_EXCHANGE_RATE.LOAD_TIMESTAMP length = 8   
      format = DATETIME20.
      informat = DATETIME20.
      label = 'LOAD_TIMESTAMP'
from
   RESASDWH.MVBS_EXCHANGE_RATE as MVBS_EXCHANGE_RATE
where
   MVBS_EXCHANGE_RATE.CURR1 = 'EUR'
   and MVBS_EXCHANGE_RATE.CATEGORY = 'DR'
   and "&reporting_period_yyyymmdd." BETWEEN FROM_TIME and TO_TIME
;
quit;

%global etls_sql_pushDown;
%let etls_sql_pushDown = &sys_sql_ip_all;

%rcSet(&sqlrc); 



/**  Step end Create Table **/

/*==========================================================================* 
 * Step:            Create Table                          A5V8BXSQ.AW0003YC * 
 * Transform:       Create Table                                            * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Tables:   MVBS_INTERIM_PC_INPUT -               A5V8BXSQ.AE0001VZ * 
 *                   RESASDWH.MVBS_INTERIM_PC_INPUT                         * 
 *                  META_MVBS_SUBJECT_FILTER -            A5V8BXSQ.AE0001UN * 
 *                   RESASDWH.META_MVBS_SUBJECT_FILTER                      * 
 * Target Table:    Create Table - work.data_delivery     A5V8BXSQ.AQ0001NF * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YC);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%global etls_sql_pushDown;
%let etls_sql_pushDown = -1;
option DBIDIRECTEXEC;

proc datasets lib = work nolist nowarn memtype = (data view);
   delete data_delivery;
quit;

proc sql
;
create table work.data_delivery as
select
   MVBS_INTERIM_PC_INPUT.CONS_UNIT length = 6   
      format = $6.
      informat = $6.
      label = 'CONS_UNIT',
   MVBS_INTERIM_PC_INPUT.GROSS_RETRO length = 10   
      format = $10.
      informat = $10.
      label = 'GROSS_RETRO',
   MVBS_INTERIM_PC_INPUT.AMT_TYPE length = 100   
      format = $100.
      informat = $100.
      label = 'AMT_TYPE',
   MVBS_INTERIM_PC_INPUT.CURR_TO_USE length = 11   
      format = $11.
      informat = $11.
      label = 'CURR_TO_USE',
   sum(MVBS_INTERIM_PC_INPUT.AMOUNT) as AMOUNT length = 8   
      format = 16.2
      informat = 16.2
      label = 'AMOUNT'
from
   RESASDWH.MVBS_INTERIM_PC_INPUT as MVBS_INTERIM_PC_INPUT
where
   MVBS_INTERIM_PC_INPUT.VERSION_ID IN (&list_of_versions.)
   and MVBS_INTERIM_PC_INPUT.QRT_RELEVANT = 'Y'
   and upcase(trim( MVBS_INTERIM_PC_INPUT.DISC_UNDISC )) = 'UNDISCOUNTED'
   and MVBS_INTERIM_PC_INPUT.LRDB_VAL_DATE = "&reporting_period_yyyymmdd."
   and upcase(trim( MVBS_INTERIM_PC_INPUT.INSTRUMENT )) = 'VA'
   and MVBS_INTERIM_PC_INPUT.CONS_UNIT IN (
      select distinct
         META_MVBS_SUBJECT_FILTER.CHAR_VALUE length = 100   
            label = 'CHAR_VALUE'
      from
         RESASDWH.META_MVBS_SUBJECT_FILTER as META_MVBS_SUBJECT_FILTER
      where
         META_MVBS_SUBJECT_FILTER.SUBJECT_GROUP = "%scan(&sub.,1,%str(_))"
         and META_MVBS_SUBJECT_FILTER.COLUMN_NAME = "LEGAL_ENTITY_CODE"
   )
group by
   MVBS_INTERIM_PC_INPUT.CONS_UNIT,
   MVBS_INTERIM_PC_INPUT.GROSS_RETRO,
   MVBS_INTERIM_PC_INPUT.AMT_TYPE,
   MVBS_INTERIM_PC_INPUT.CURR_TO_USE
;
quit;

%global etls_sql_pushDown;
%let etls_sql_pushDown = &sys_sql_ip_all;

%rcSet(&sqlrc); 



/**  Step end Create Table **/

/*==========================================================================* 
 * Step:            Create Table                          A5V8BXSQ.AW0003YD * 
 * Transform:       Create Table                                            * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Tables:   MVBS_OUTPUT_4SM_AGG -                 A5V8BXSQ.AE0001WA * 
 *                   RESASDWH.MVBS_OUTPUT_4SM_AGG                           * 
 *                  Create Table - work.data_delivery     A5V8BXSQ.AQ0001NF * 
 * Target Table:    Create Table - work.sm_output         A5V8BXSQ.AQ0001NG * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YD);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%global etls_sql_pushDown;
%let etls_sql_pushDown = -1;
option DBIDIRECTEXEC;

proc datasets lib = work nolist nowarn memtype = (data view);
   delete sm_output;
quit;

proc sql
;
create table work.sm_output as
select
   coalescec(data_delivery.CONS_UNIT, output_sm.LEGAL_ENTITY_CODE) as CONS_UNIT length = 6   
      format = $6.
      informat = $6.
      label = 'CONS_UNIT',
   coalescec(data_delivery.GROSS_RETRO, output_sm.GROSSRETRO) as GROSS_RETRO length = 10   
      format = $10.
      informat = $10.
      label = 'GROSS_RETRO',
   coalescec(data_delivery.AMT_TYPE, output_sm.AMT_TYPE) as AMT_TYPE length = 100   
      format = $100.
      informat = $100.
      label = 'AMT_TYPE',
   output_sm.AMT_TYPE_SM length = 100   
      format = $100.
      informat = $100.
      label = 'AMT_TYPE_SM',
   coalescec(data_delivery.CURR_TO_USE, output_sm.CURR_TO_USE) as CURR_TO_USE length = 11   
      format = $11.
      informat = $11.
      label = 'CURR_TO_USE',
   data_delivery.AMOUNT as AMOUNT_INPUT length = 8   
      format = 16.2
      informat = 16.2
      label = 'AMOUNT_INPUT',
   output_sm.SM_AMOUNT as AMOUNT_SM length = 8   
      format = 16.2
      informat = 16.2
      label = 'AMOUNT_SM'
from
   work.data_delivery as data_delivery full join 
   (
      select
         MVBS_OUTPUT_4SM_AGG.LEGAL_ENTITY_CODE length = 6   
            format = $6.
            informat = $6.
            label = 'LEGAL_ENTITY_CODE',
         MVBS_OUTPUT_4SM_AGG.AMT_TYPE_SM length = 100   
            format = $100.
            informat = $100.
            label = 'AMT_TYPE_SM',
         MVBS_OUTPUT_4SM_AGG.AMT_TYPE length = 100   
            format = $100.
            informat = $100.
            label = 'AMT_TYPE',
         MVBS_OUTPUT_4SM_AGG.CURR_TO_USE length = 11   
            format = $11.
            informat = $11.
            label = 'CURR_TO_USE',
         MVBS_OUTPUT_4SM_AGG.GROSSRETRO length = 44   
            format = $44.
            informat = $44.
            label = 'GROSSRETRO',
         sum(MVBS_OUTPUT_4SM_AGG.SM_AMOUNT) as SM_AMOUNT length = 8   
            label = 'SM_AMOUNT'
      from
         RESASDWH.MVBS_OUTPUT_4SM_AGG as MVBS_OUTPUT_4SM_AGG
      group by
         MVBS_OUTPUT_4SM_AGG.LEGAL_ENTITY_CODE,
         MVBS_OUTPUT_4SM_AGG.GROSSRETRO,
         MVBS_OUTPUT_4SM_AGG.AMT_TYPE_SM,
         MVBS_OUTPUT_4SM_AGG.AMT_TYPE,
         MVBS_OUTPUT_4SM_AGG.CURR_TO_USE
   ) as output_sm
      on
      (
         data_delivery.CONS_UNIT = output_sm.LEGAL_ENTITY_CODE
         and data_delivery.GROSS_RETRO = output_sm.GROSSRETRO
         and data_delivery.AMT_TYPE = output_sm.AMT_TYPE
         and data_delivery.CURR_TO_USE = output_sm.CURR_TO_USE
      )
;
quit;

%global etls_sql_pushDown;
%let etls_sql_pushDown = &sys_sql_ip_all;

%rcSet(&sqlrc); 



/**  Step end Create Table **/

/*==========================================================================* 
 * Step:            Create Table                          A5V8BXSQ.AW0003YE * 
 * Transform:       Create Table                                            * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Tables:   Create Table - work.sm_output         A5V8BXSQ.AQ0001NG * 
 *                  Create Table - work.fx_rates          A5V8BXSQ.AQ0001NE * 
 * Target Table:    Create Table - work.csv_output        A5V8BXSQ.AQ0001NH * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YE);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%global etls_sql_pushDown;
%let etls_sql_pushDown = -1;
option DBIDIRECTEXEC;

proc datasets lib = work nolist nowarn memtype = (data view);
   delete csv_output;
quit;

proc sql
;
create table work.csv_output as
select
   sm_output.CONS_UNIT length = 6   
      format = $6.
      informat = $6.
      label = 'CONS_UNIT',
   sm_output.GROSS_RETRO length = 10   
      format = $10.
      informat = $10.
      label = 'GROSS_RETRO',
   sm_output.AMT_TYPE length = 100   
      format = $100.
      informat = $100.
      label = 'AMT_TYPE',
   sm_output.AMT_TYPE_SM length = 100   
      format = $100.
      informat = $100.
      label = 'AMT_TYPE_SM',
   sum(sm_output.AMOUNT_INPUT) as AMOUNT_INPUT length = 8   
      format = 16.2
      informat = 16.2
      label = 'AMOUNT_INPUT',
   sum(sm_output.AMOUNT_SM) as AMOUNT_SM length = 8   
      format = 16.2
      informat = 16.2
      label = 'AMOUNT_SM',
   sum(  
      case  
         when missing(fx_rates.RATE) then 0  
         else sm_output.AMOUNT_INPUT / fx_rates.RATE 
      end  
   ) as EUR_AMOUNT_INPUT length = 8   
      format = 16.2
      informat = 16.2
      label = 'EUR_AMOUNT_INPUT',
   sum(  
      case  
         when missing(fx_rates.RATE) then 0  
         else sm_output.AMOUNT_SM / fx_rates.RATE 
      end  
   ) as EUR_AMOUNT_SM length = 8   
      format = 16.2
      informat = 16.2
      label = 'EUR_AMOUNT_SM'
from
   work.sm_output as sm_output left join 
   work.fx_rates as fx_rates
      on
      (
         sm_output.CURR_TO_USE = fx_rates.CURR2
      )
group by
   sm_output.CONS_UNIT,
   sm_output.GROSS_RETRO,
   sm_output.AMT_TYPE,
   sm_output.AMT_TYPE_SM
;
quit;

%global etls_sql_pushDown;
%let etls_sql_pushDown = &sys_sql_ip_all;

%rcSet(&sqlrc); 



/**  Step end Create Table **/

/*==========================================================================* 
 * Step:            MVBS TDB BULK_CSV_WRITE               A5V8BXSQ.AW0003YF * 
 * Transform:       MVBS TDB BULK_CSV_WRITE                                 * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Table:    Create Table - work.csv_output        A5V8BXSQ.AQ0001NH * 
 * Target Table:    MVBS TDB BULK_CSV_WRITE_OUTPUT -      A5V8BXSQ.AQ0001NI * 
 *                   work.WGQWZ26                                           * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YF);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let SYSLAST = %nrquote(work.csv_output); 

%let _INPUT_count = 1; 
%let _INPUT = work.csv_output;
%let _INPUT_connect = ;
%let _INPUT_engine = ;
%let _INPUT_memtype = DATA;
%let _INPUT_options = %nrquote();
%let _INPUT_alter = %nrquote();
%let _INPUT_path = %nrquote(/Create Table_A5V8BXSQ.AQ0001NH%(WorkTable%));
%let _INPUT_type = 1;
%let _INPUT_label = %nrquote();

%let _INPUT0 = work.csv_output;
%let _INPUT0_connect = ;
%let _INPUT0_engine = ;
%let _INPUT0_memtype = DATA;
%let _INPUT0_options = %nrquote();
%let _INPUT0_alter = %nrquote();
%let _INPUT0_path = %nrquote(/Create Table_A5V8BXSQ.AQ0001NH%(WorkTable%));
%let _INPUT0_type = 1;
%let _INPUT0_label = %nrquote();

%let _OUTPUT_count = 1; 
%let _OUTPUT = work.WGQWZ26;
%let _OUTPUT_connect = ;
%let _OUTPUT_engine = ;
%let _OUTPUT_memtype = DATA;
%let _OUTPUT_options = %nrquote();
%let _OUTPUT_alter = %nrquote();
%let _OUTPUT_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NI%(WorkTable%));
%let _OUTPUT_type = 1;
%let _OUTPUT_label = %nrquote();
/* List of target columns to keep  */ 
%let _OUTPUT_keep = FILENAME;

%let _OUTPUT_BULK_CSV = work.WGQWZ26;
%let _OUTPUT_BULK_CSV_connect = ;
%let _OUTPUT_BULK_CSV_engine = ;
%let _OUTPUT_BULK_CSV_memtype = DATA;
%let _OUTPUT_BULK_CSV_options = %nrquote();
%let _OUTPUT_BULK_CSV_alter = %nrquote();
%let _OUTPUT_BULK_CSV_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NI%(WorkTable%));
%let _OUTPUT_BULK_CSV_type = 1;
%let _OUTPUT_BULK_CSV_label = %nrquote();
/* List of target columns to keep  */ 
%let _OUTPUT_BULK_CSV_keep = FILENAME;


%let filename = %nrquote(%str("mvbs_output/&sub._CASO_&reporting_period..csv"));
%let header_count = %nrquote(0);
%let header = ;
%let column = CONS_UNIT GROSS_RETRO AMT_TYPE AMT_TYPE_SM AMOUNT_INPUT AMOUNT_SM 
EUR_AMOUNT_INPUT EUR_AMOUNT_SM;
%let column_count = 8;
%let column0 = 8;
%let column1 = CONS_UNIT;
%let column2 = GROSS_RETRO;
%let column3 = AMT_TYPE;
%let column4 = AMT_TYPE_SM;
%let column5 = AMOUNT_INPUT;
%let column6 = AMOUNT_SM;
%let column7 = EUR_AMOUNT_INPUT;
%let column8 = EUR_AMOUNT_SM;
%let columnHeaders = %nrquote(YES);
%let file_open_mode = %nrquote(o);
%let by_group = ;
%let by_group_count = 0;
%let by_group0 = 0;
%let by_group = ;
%let orderbycolumn = ;
%let orderbycolumn_count = 0;
%let orderbycolumn0 = 0;
%let orderbycolumn = ;
%let path = ;
%let dlm = %nrquote(semi);
%let dlm1 = ;
%let where = ;
%let TERMSTR = %nrquote(TERMSTR=CRLF);

/* List of target columns to keep  */ 
%let _keep = FILENAME;
/* List of target columns to keep  */ 
%let keep = FILENAME;
/*****************************************************************************************************************************/
/*********** CODE FOR WRITING THE SELECTED INPUT COLUMNS TO EXTERANAL CSV FILE ***********************************************/
/*****************************************************************************************************************************/

options noquotelenmax;

/* New prompt file_open_mode introduced. Must have "o" as default value for compatibility reasons */
%global file_open_mode;
%let file_open_mode=%sysfunc(coalescec(&file_open_mode., o));

%macro define_delimiter;
%global dlm2;
%if  &dlm eq semi %then %do;
%let dlm2=%str(;);
%end;
%if  &dlm eq others %then %do;
data _null_;
call symput('dlm2',"&dlm1");
run;%end;
%if &dlm eq comma %then %do;
%let dlm2=%str(,);
%end;
%mend define_delimiter;
%define_delimiter;

data _null_;
length g $100.;
g=tranwrd("&orderbycolumn"," ",",");
call symput('orderbycol',compress(g));
run;

data _null_; 
length COlUMN_LIST $2000;  
if symget('column_count')=1 then COlUMN_LIST=trim(symget('column')); 
else do i=1 to symget('column_count'); 
COlUMN_LIST= catx("&dlm2" ,COlUMN_LIST, trim(symget(cats('column',i)))); 
end; 
if missing(COlUMN_LIST)=0 then 
call symputx('column_list',COlUMN_LIST); 
run; 

%macro dd3;
%if &orderbycolumn ne  %then %do;
proc sql;
create table order_table as select * from &_input
order by &orderbycol;
quit;
%end;
%mend dd3;
%dd3;

%macro produce_csv;
	%local firstDataRowOfGroup lastDataRowOfGroup byStatement;
	%if "&by_group." ne "" %then %do;
        %let byStatement = %str(by &by_group;);
		%let firstDataRowOfGroup = first.%scan(&by_group., %sysfunc(countw(&by_group.)));
		%let lastDataRowOfGroup  = last.%scan(&by_group., %sysfunc(countw(&by_group.)));
	%end;
	%else %do;
        %let byStatement = ;
		%let firstDataRowOfGroup = %str(_N_=1);
		%let lastDataRowOfGroup  = %str(eof=1);
	%end;

	/* check whether an output table is defined to collect all filenames of CSV files that are created in this step */
	%local outTable outKeep;

	%if %symexist(_OUTPUT_BULK_CSV) = 1 %then %do;
		%if %quote(&_OUTPUT_BULK_CSV.) eq %then %do;
			/* No output table defined, set output to _null_ for the following data step */
			%let outTable = _null_;
			%let outKeep = ;
		%end;
		%else %do;
			/* Output table defined, set local variables outTable and outKeep */
			%let outTable = &_OUTPUT_BULK_CSV.;
			%let outKeep = (keep=&_OUTPUT_BULK_CSV_keep.);
		%end;
	%end;
	%else %do;
			/*
			 * No output table defined, set output to _null_ for the following data step.
			 * Create a local dummy macro variable in order to avoid warnings/errors when executing the rest of the code
			 * (which relies on an existing macro variable).
			 */
		%local _OUTPUT_BULK_CSV;
		%let outTable = _null_;
		%let outKeep = ;
	%end;

	data &outTable.&outKeep.;
		%if "&orderbycolumn" ne "" %then %do;
			set order_table end=eof;
		%end;
		%else %do;
			set &_input end=eof;
		%end;
		where &where.;
		length column_put $2000 filename $1000 header $2000;
		retain file_count 0 file_id;

		&byStatement.

		if &firstDataRowOfGroup. then do;
			filename = strip("&proj_env./data/" || &filename.);
			rc = filename('ft' || strip(file_count), strip(filename) , 'DISK' , "&TERMSTR.");			
			file_id = fopen('ft' || strip(file_count), "&file_open_mode.", 1000, 'v');
			%do header_nr = 1 %to &header_count.;
				%let my_header = %sysfunc(trim(&&header&header_nr.));
				header = trim(&my_header.);
				rcp = fput(file_id, strip(header));
				rcw = fwrite(file_id);
			%end;
			%if %upcase(&columnHeaders.) eq YES %then %do;
				rcp = fput(file_id, "&column_list.");
				rcw = fwrite(file_id);
			%end;
			%else %if %upcase(&columnHeaders.) eq LABELS %then %do;
				header = strip(vlabelx(scan("&column.", 1)));
				do count = 2 to countw("&column.");
					col = scan("&column.", count);
					header = strip(header) || "&dlm2" || strip(vlabelx(col));
				end;
				rcp = fput(file_id, strip(header));
				rcw = fwrite(file_id);
			%end;

			%if %quote(&_OUTPUT_BULK_CSV.) ne %then %do;
				/* Add current file name to the output table containing all file names. */
				output &outTable.;
			%end;

			file_count + 1;
		end;
 
/*      if  ( ifc(index(upcase("&column"),"NOMINAL")>1, vvaluex(scan("&column.", 5)),1) ne  0 ) */
/*         then do;*/

		/* If condition - added as part of user story TDB-156. */
			column_put = strip(vvaluex(scan("&column.", 1)));
			do count = 2 to countw("&column.");
				col = scan("&column.", count);
				column_put = strip(column_put) || "&dlm2" || strip(vvaluex(col));
			end;
			rcp = fput(file_id, strip(column_put));
			rcw = fwrite(file_id);
/*     end;*/
		if &lastDataRowOfGroup. then do;
			rcc = fclose(file_id);

			%if %quote(&_OUTPUT_BULK_CSV.) eq %then %do;
				/* No output table defined -> add files directly to a zip file (default beaviour until 2015Q3 release) */
				%if "&path" eq "" %then %do;
					call execute('ods package(LongRun) add file=' ||'"' || strip("&proj_env/data/" || &filename.)  || '"' ||';');
				%end;
				%else %do;
					call execute('ods package(LongRun) add file=' ||'"' || strip("&proj_env/data/" || &filename.)  || '"' 
									|| ' path =' || '"' || &path. || '"' ||';');
				%end;
			%end;
		end;
	run;

	/* Delete output macro variable, just to be sure that no subsequent "BULK CSV write" gets in trouble */
	%symdel _OUTPUT_BULK_CSV;
%mend;
%produce_csv;

%rcSet(&syserr); 
%rcSet(&sysrc); 
%rcSet(&sqlrc); 



/**  Step end MVBS TDB BULK_CSV_WRITE **/

/*==========================================================================* 
 * Step:            Create Table                          A5V8BXSQ.AW0003YG * 
 * Transform:       Create Table                                            * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Tables:   META_MVBS_AMOUNT_TYPE -               A5V8BXSQ.AE0001TX * 
 *                   RESASDWH.META_MVBS_AMOUNT_TYPE                         * 
 *                  MVBS_OUTPUT_4SM_CDA -                 A5V8BXSQ.AE0001WC * 
 *                   RESASDWH.MVBS_OUTPUT_4SM_CDA                           * 
 *                  MVBS_OUTPUT_4SM_CASO -                A5V8BXSQ.AE0001WB * 
 *                   RESASDWH.MVBS_OUTPUT_4SM_CASO                          * 
 * Target Table:    Create Table -                        A5V8BXSQ.AQ0001NJ * 
 *                   work.SM_CDA_percentages                                * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YG);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%global etls_sql_pushDown;
%let etls_sql_pushDown = -1;
option DBIDIRECTEXEC;

proc datasets lib = work nolist nowarn memtype = (data view);
   delete SM_CDA_percentages;
quit;

proc sql
;
create table work.SM_CDA_percentages as
select
   coalescec(retro_for_cda.LEGAL_ENTITY_CODE, MVBS_OUTPUT_4SM_CDA.CONS_UNIT) as LEGAL_ENTITY_CODE length = 6   
      format = $6.
      informat = $6.,
   coalescec(retro_for_cda.CURRENCY, MVBS_OUTPUT_4SM_CDA.CURRENCY) as CURRENCY length = 3,
   sum( 
      case 
         when MVBS_OUTPUT_4SM_CDA.CDA_TYPE = 'Prospective' then MVBS_OUTPUT_4SM_CDA.VALUE 
         else 0 
      end 
   ) as PREMIUMS_CDA length = 8,
   sum( 
      case 
         when retro_for_cda.PREMIUMS_CLAIMS_FLAG = 'P' then retro_for_cda.EUR_AMOUNT 
         else 0 
      end 
   ) as PREMIUMS_TOTAL length = 8,
   round(sum( 
      case 
         when MVBS_OUTPUT_4SM_CDA.CDA_TYPE = 'Prospective' and retro_for_cda.PREMIUMS_CLAIMS_FLAG = 'P' and retro_for_cda.EUR_AMOUNT ne 0 
            then MVBS_OUTPUT_4SM_CDA.VALUE / retro_for_cda.EUR_AMOUNT * 100
         else . 
      end 
   ),.1) as PREMIUMS_PCT length = 8,
   sum( 
      case 
         when MVBS_OUTPUT_4SM_CDA.CDA_TYPE = 'Retrospective' then MVBS_OUTPUT_4SM_CDA.VALUE 
         else 0 
      end 
   ) as CLAIMS_CDA length = 8,
   sum( 
      case 
         when retro_for_cda.PREMIUMS_CLAIMS_FLAG = 'L' then retro_for_cda.EUR_AMOUNT 
         else 0 
      end 
   ) as CLAIMS_TOTAL length = 8,
   round(sum( 
      case 
         when MVBS_OUTPUT_4SM_CDA.CDA_TYPE = 'Retrospective' and retro_for_cda.PREMIUMS_CLAIMS_FLAG = 'L' and retro_for_cda.EUR_AMOUNT ne 0 
            then MVBS_OUTPUT_4SM_CDA.VALUE / retro_for_cda.EUR_AMOUNT * 100
         else . 
      end 
   ),.1) as CLAIMS_PCT length = 8
from
   (
      select
         MVBS_OUTPUT_4SM_CASO.LEGAL_ENTITY_CODE length = 6   
            format = $6.
            informat = $6.
            label = 'LEGAL_ENTITY_CODE',
         MVBS_OUTPUT_4SM_CASO.CURRENCY length = 3   
            label = 'CURRENCY',
         case 
            when META_MVBS_AMOUNT_TYPE.CALC_CDA_FLAG = 'P' then 'P' 
            else 'L' 
         end as PREMIUMS_CLAIMS_FLAG length = 1,
         sum(MVBS_OUTPUT_4SM_CASO.EUR_AMOUNT) as EUR_AMOUNT length = 8   
            label = 'EUR_AMOUNT'
      from
         RESASDWH.MVBS_OUTPUT_4SM_CASO as MVBS_OUTPUT_4SM_CASO inner join 
         RESASDWH.META_MVBS_AMOUNT_TYPE as META_MVBS_AMOUNT_TYPE
            on
            (
               MVBS_OUTPUT_4SM_CASO.AMT_TYPE = META_MVBS_AMOUNT_TYPE.AMT_TYPE
            )
      group by
         MVBS_OUTPUT_4SM_CASO.LEGAL_ENTITY_CODE,
         MVBS_OUTPUT_4SM_CASO.CURRENCY,
         3
   ) as retro_for_cda full join 
   (
      select
         MVBS_OUTPUT_4SM_CDA.CONS_UNIT length = 6   
            label = 'CONS_UNIT',
         MVBS_OUTPUT_4SM_CDA.CURRENCY length = 3   
            label = 'CURRENCY',
         MVBS_OUTPUT_4SM_CDA.CDA_TYPE length = 15   
            label = 'CDA_TYPE',
         sum(MVBS_OUTPUT_4SM_CDA.VALUE) as VALUE length = 8   
            label = 'VALUE'
      from
         RESASDWH.MVBS_OUTPUT_4SM_CDA as MVBS_OUTPUT_4SM_CDA
      group by
         MVBS_OUTPUT_4SM_CDA.CONS_UNIT,
         MVBS_OUTPUT_4SM_CDA.CURRENCY,
         MVBS_OUTPUT_4SM_CDA.CDA_TYPE
   ) as MVBS_OUTPUT_4SM_CDA
      on
      (
         retro_for_cda.LEGAL_ENTITY_CODE = MVBS_OUTPUT_4SM_CDA.CONS_UNIT
         and (retro_for_cda.PREMIUMS_CLAIMS_FLAG = 'P'
         and MVBS_OUTPUT_4SM_CDA.CDA_TYPE = 'Prospective'
         or retro_for_cda.PREMIUMS_CLAIMS_FLAG = 'L'
         and MVBS_OUTPUT_4SM_CDA.CDA_TYPE = 'Retrospective')
      )
group by
   1,
   2
;
quit;

%global etls_sql_pushDown;
%let etls_sql_pushDown = &sys_sql_ip_all;

%rcSet(&sqlrc); 



/**  Step end Create Table **/

/*==========================================================================* 
 * Step:            MVBS TDB BULK_CSV_WRITE               A5V8BXSQ.AW0003YI * 
 * Transform:       MVBS TDB BULK_CSV_WRITE                                 * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Table:    Create Table -                        A5V8BXSQ.AQ0001NJ * 
 *                   work.SM_CDA_percentages                                * 
 * Target Table:    MVBS TDB BULK_CSV_WRITE_OUTPUT -      A5V8BXSQ.AQ0001NL * 
 *                   work.WGQZ8FT                                           * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YI);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let SYSLAST = %nrquote(work.SM_CDA_percentages); 

%let _INPUT_count = 1; 
%let _INPUT = work.SM_CDA_percentages;
%let _INPUT_connect = ;
%let _INPUT_engine = ;
%let _INPUT_memtype = DATA;
%let _INPUT_options = %nrquote();
%let _INPUT_alter = %nrquote();
%let _INPUT_path = %nrquote(/Create Table_A5V8BXSQ.AQ0001NJ%(WorkTable%));
%let _INPUT_type = 1;
%let _INPUT_label = %nrquote();

%let _INPUT0 = work.SM_CDA_percentages;
%let _INPUT0_connect = ;
%let _INPUT0_engine = ;
%let _INPUT0_memtype = DATA;
%let _INPUT0_options = %nrquote();
%let _INPUT0_alter = %nrquote();
%let _INPUT0_path = %nrquote(/Create Table_A5V8BXSQ.AQ0001NJ%(WorkTable%));
%let _INPUT0_type = 1;
%let _INPUT0_label = %nrquote();

%let _OUTPUT_count = 1; 
%let _OUTPUT = work.WGQZ8FT;
%let _OUTPUT_connect = ;
%let _OUTPUT_engine = ;
%let _OUTPUT_memtype = DATA;
%let _OUTPUT_options = %nrquote();
%let _OUTPUT_alter = %nrquote();
%let _OUTPUT_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NL%(WorkTable%));
%let _OUTPUT_type = 1;
%let _OUTPUT_label = %nrquote();
/* List of target columns to keep  */ 
%let _OUTPUT_keep = FILENAME;

%let _OUTPUT_BULK_CSV = work.WGQZ8FT;
%let _OUTPUT_BULK_CSV_connect = ;
%let _OUTPUT_BULK_CSV_engine = ;
%let _OUTPUT_BULK_CSV_memtype = DATA;
%let _OUTPUT_BULK_CSV_options = %nrquote();
%let _OUTPUT_BULK_CSV_alter = %nrquote();
%let _OUTPUT_BULK_CSV_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NL%(WorkTable%));
%let _OUTPUT_BULK_CSV_type = 1;
%let _OUTPUT_BULK_CSV_label = %nrquote();
/* List of target columns to keep  */ 
%let _OUTPUT_BULK_CSV_keep = FILENAME;


%let filename = %nrquote(%str("mvbs_output/&sub._CDA_&reporting_period..csv"));
%let header_count = %nrquote(0);
%let header = ;
%let column = LEGAL_ENTITY_CODE CURRENCY PREMIUMS_CDA PREMIUMS_TOTAL PREMIUMS_PCT CLAIMS_CDA 
CLAIMS_TOTAL CLAIMS_PCT;
%let column_count = 8;
%let column0 = 8;
%let column1 = LEGAL_ENTITY_CODE;
%let column2 = CURRENCY;
%let column3 = PREMIUMS_CDA;
%let column4 = PREMIUMS_TOTAL;
%let column5 = PREMIUMS_PCT;
%let column6 = CLAIMS_CDA;
%let column7 = CLAIMS_TOTAL;
%let column8 = CLAIMS_PCT;
%let columnHeaders = %nrquote(YES);
%let file_open_mode = %nrquote(o);
%let by_group = ;
%let by_group_count = 0;
%let by_group0 = 0;
%let by_group = ;
%let orderbycolumn = ;
%let orderbycolumn_count = 0;
%let orderbycolumn0 = 0;
%let orderbycolumn = ;
%let path = ;
%let dlm = %nrquote(semi);
%let dlm1 = ;
%let where = ;
%let TERMSTR = %nrquote(TERMSTR=CRLF);

/* List of target columns to keep  */ 
%let _keep = FILENAME;
/* List of target columns to keep  */ 
%let keep = FILENAME;
/*****************************************************************************************************************************/
/*********** CODE FOR WRITING THE SELECTED INPUT COLUMNS TO EXTERANAL CSV FILE ***********************************************/
/*****************************************************************************************************************************/

options noquotelenmax;

/* New prompt file_open_mode introduced. Must have "o" as default value for compatibility reasons */
%global file_open_mode;
%let file_open_mode=%sysfunc(coalescec(&file_open_mode., o));

%macro define_delimiter;
%global dlm2;
%if  &dlm eq semi %then %do;
%let dlm2=%str(;);
%end;
%if  &dlm eq others %then %do;
data _null_;
call symput('dlm2',"&dlm1");
run;%end;
%if &dlm eq comma %then %do;
%let dlm2=%str(,);
%end;
%mend define_delimiter;
%define_delimiter;

data _null_;
length g $100.;
g=tranwrd("&orderbycolumn"," ",",");
call symput('orderbycol',compress(g));
run;

data _null_; 
length COlUMN_LIST $2000;  
if symget('column_count')=1 then COlUMN_LIST=trim(symget('column')); 
else do i=1 to symget('column_count'); 
COlUMN_LIST= catx("&dlm2" ,COlUMN_LIST, trim(symget(cats('column',i)))); 
end; 
if missing(COlUMN_LIST)=0 then 
call symputx('column_list',COlUMN_LIST); 
run; 

%macro dd3;
%if &orderbycolumn ne  %then %do;
proc sql;
create table order_table as select * from &_input
order by &orderbycol;
quit;
%end;
%mend dd3;
%dd3;

%macro produce_csv;
	%local firstDataRowOfGroup lastDataRowOfGroup byStatement;
	%if "&by_group." ne "" %then %do;
        %let byStatement = %str(by &by_group;);
		%let firstDataRowOfGroup = first.%scan(&by_group., %sysfunc(countw(&by_group.)));
		%let lastDataRowOfGroup  = last.%scan(&by_group., %sysfunc(countw(&by_group.)));
	%end;
	%else %do;
        %let byStatement = ;
		%let firstDataRowOfGroup = %str(_N_=1);
		%let lastDataRowOfGroup  = %str(eof=1);
	%end;

	/* check whether an output table is defined to collect all filenames of CSV files that are created in this step */
	%local outTable outKeep;

	%if %symexist(_OUTPUT_BULK_CSV) = 1 %then %do;
		%if %quote(&_OUTPUT_BULK_CSV.) eq %then %do;
			/* No output table defined, set output to _null_ for the following data step */
			%let outTable = _null_;
			%let outKeep = ;
		%end;
		%else %do;
			/* Output table defined, set local variables outTable and outKeep */
			%let outTable = &_OUTPUT_BULK_CSV.;
			%let outKeep = (keep=&_OUTPUT_BULK_CSV_keep.);
		%end;
	%end;
	%else %do;
			/*
			 * No output table defined, set output to _null_ for the following data step.
			 * Create a local dummy macro variable in order to avoid warnings/errors when executing the rest of the code
			 * (which relies on an existing macro variable).
			 */
		%local _OUTPUT_BULK_CSV;
		%let outTable = _null_;
		%let outKeep = ;
	%end;

	data &outTable.&outKeep.;
		%if "&orderbycolumn" ne "" %then %do;
			set order_table end=eof;
		%end;
		%else %do;
			set &_input end=eof;
		%end;
		where &where.;
		length column_put $2000 filename $1000 header $2000;
		retain file_count 0 file_id;

		&byStatement.

		if &firstDataRowOfGroup. then do;
			filename = strip("&proj_env./data/" || &filename.);
			rc = filename('ft' || strip(file_count), strip(filename) , 'DISK' , "&TERMSTR.");			
			file_id = fopen('ft' || strip(file_count), "&file_open_mode.", 1000, 'v');
			%do header_nr = 1 %to &header_count.;
				%let my_header = %sysfunc(trim(&&header&header_nr.));
				header = trim(&my_header.);
				rcp = fput(file_id, strip(header));
				rcw = fwrite(file_id);
			%end;
			%if %upcase(&columnHeaders.) eq YES %then %do;
				rcp = fput(file_id, "&column_list.");
				rcw = fwrite(file_id);
			%end;
			%else %if %upcase(&columnHeaders.) eq LABELS %then %do;
				header = strip(vlabelx(scan("&column.", 1)));
				do count = 2 to countw("&column.");
					col = scan("&column.", count);
					header = strip(header) || "&dlm2" || strip(vlabelx(col));
				end;
				rcp = fput(file_id, strip(header));
				rcw = fwrite(file_id);
			%end;

			%if %quote(&_OUTPUT_BULK_CSV.) ne %then %do;
				/* Add current file name to the output table containing all file names. */
				output &outTable.;
			%end;

			file_count + 1;
		end;
 
/*      if  ( ifc(index(upcase("&column"),"NOMINAL")>1, vvaluex(scan("&column.", 5)),1) ne  0 ) */
/*         then do;*/

		/* If condition - added as part of user story TDB-156. */
			column_put = strip(vvaluex(scan("&column.", 1)));
			do count = 2 to countw("&column.");
				col = scan("&column.", count);
				column_put = strip(column_put) || "&dlm2" || strip(vvaluex(col));
			end;
			rcp = fput(file_id, strip(column_put));
			rcw = fwrite(file_id);
/*     end;*/
		if &lastDataRowOfGroup. then do;
			rcc = fclose(file_id);

			%if %quote(&_OUTPUT_BULK_CSV.) eq %then %do;
				/* No output table defined -> add files directly to a zip file (default beaviour until 2015Q3 release) */
				%if "&path" eq "" %then %do;
					call execute('ods package(LongRun) add file=' ||'"' || strip("&proj_env/data/" || &filename.)  || '"' ||';');
				%end;
				%else %do;
					call execute('ods package(LongRun) add file=' ||'"' || strip("&proj_env/data/" || &filename.)  || '"' 
									|| ' path =' || '"' || &path. || '"' ||';');
				%end;
			%end;
		end;
	run;

	/* Delete output macro variable, just to be sure that no subsequent "BULK CSV write" gets in trouble */
	%symdel _OUTPUT_BULK_CSV;
%mend;
%produce_csv;

%rcSet(&syserr); 
%rcSet(&sysrc); 
%rcSet(&sqlrc); 



/**  Step end MVBS TDB BULK_CSV_WRITE **/

/*==========================================================================* 
 * Step:            MVBS TDB Create zip file              A5V8BXSQ.AW0003YJ * 
 * Transform:       MVBS TDB Create zip file                                * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Tables:   MVBS TDB BULK_CSV_WRITE_OUTPUT -      A5V8BXSQ.AQ0001NI * 
 *                   work.WGQWZ26                                           * 
 *                  MVBS TDB BULK_CSV_WRITE_OUTPUT -      A5V8BXSQ.AQ0001NL * 
 *                   work.WGQZ8FT                                           * 
 *==========================================================================*/ 

%let transformID = %quote(A5V8BXSQ.AW0003YJ);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let _INPUT_count = 2; 
%let _INPUT = work.WGQWZ26;
%let _INPUT_connect = ;
%let _INPUT_engine = ;
%let _INPUT_memtype = DATA;
%let _INPUT_options = %nrquote();
%let _INPUT_alter = %nrquote();
%let _INPUT_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NI%(WorkTable%));
%let _INPUT_type = 1;
%let _INPUT_label = %nrquote();

%let _INPUT0 = work.WGQWZ26;
%let _INPUT0_connect = ;
%let _INPUT0_engine = ;
%let _INPUT0_memtype = DATA;
%let _INPUT0_options = %nrquote();
%let _INPUT0_alter = %nrquote();
%let _INPUT0_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NI%(WorkTable%));
%let _INPUT0_type = 1;
%let _INPUT0_label = %nrquote();

%let _INPUT1 = work.WGQZ8FT;
%let _INPUT1_connect = ;
%let _INPUT1_engine = ;
%let _INPUT1_memtype = DATA;
%let _INPUT1_options = %nrquote();
%let _INPUT1_alter = %nrquote();
%let _INPUT1_path = %nrquote(/MVBS TDB BULK_CSV_WRITE_OUTPUT_A5V8BXSQ.AQ0001NL%(WorkTable%));
%let _INPUT1_type = 1;
%let _INPUT1_label = %nrquote();

%let _OUTPUT_count = 0; 

%let zipFilePath = %nrquote(&proj_env./data/mvbs_output/);
%let zipFileName = %nrquote(%str("&sub._CASO.zip"));

%macro createZIP;
   /* Open a new zip archive */
   ods package open nopf;

   /* Add the required files to the zip archive */	
	%do inputCount=0 %to %eval(&_INPUT_count. - 1);
	   data _null_;
	      length filename path $1000;
	      set &&_INPUT&inputCount;
	
	      if missing(path) then
	         call execute('ods package add file="' || strip(filename) || '";');
	      else
	         call execute('ods package add file="' || strip(filename) || '"  path = "' || strip(path) || '";');
	   run;
	%end;
	
   /*
    * Store the zip archive to the file system.
    * No quotation marks around zipFileName because this macro variable may contain ANY statement
    * (and therefore must also take care of the quotes).
    */
   ods package publish archive properties(archive_name=&zipFileName. archive_path="&zipFilePath.");

   /* Close the zip archive and delete the ods package object */
   ods package close;
%mend;

%createZIP;

%rcSet(&syserr); 
%rcSet(&sysrc); 
%rcSet(&sqlrc); 



/**  Step end MVBS TDB Create zip file **/

%let etls_endTime = %sysfunc(datetime(),datetime.);

/* Check return code for job  */ 
%macro etls_jobRCChk; 
   %if (&job_rc ge 5) %then
   %do; 
      %macro etls_sendEmail(address=, message=); 
      
         filename sendMail email "&address" subject='ETL Process Status'; 
      
         %local etls_syntaxcheck; 
         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); 
         /* Turn off syntaxcheck option to perform following steps  */ 
         options nosyntaxcheck;
      
         data _null_; 
            file sendMail; 
            dttm = put(datetime(),nldatm.); 
            put dttm "&message."; 
         run; 
      
         /* Reset syntaxcheck option to previous setting  */ 
         options &etls_syntaxcheck; 
      %mend etls_sendEmail; 
      %etls_sendEmail 
         (address = &mail_to, 
          Message = %str(&etls_jobName Error auf &run_system : Error%%superq%(syserrortext%))); 
   %end; 
%mend etls_jobRCChk; 
%etls_jobRCChk; 

/* Check return code for job  */ 
%macro etls_jobRCChk; 
   %if (&job_rc ge 5) %then
   %do; 
      %macro etls_sendFile(directory=, filename=, message=); 
      
         filename sendfile "&directory.&filename"; 
      
         %local etls_syntaxcheck; 
         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); 
         /* Turn off syntaxcheck option to perform following steps  */ 
         options nosyntaxcheck;
      
         data _null_; 
            file sendFile; 
            dttm = put(datetime(),nldatm.); 
            put dttm "&message."; 
         run; 
      
         /* Reset syntaxcheck option to previous setting  */ 
         options &etls_syntaxcheck; 
      %mend etls_sendFile; 
      %etls_sendFile 
         (FileName = &proj_env./run_control/mvbs_error_&etls_jobName, 
          Message = Error); 
   %end; 
%mend etls_jobRCChk; 
%etls_jobRCChk; 

